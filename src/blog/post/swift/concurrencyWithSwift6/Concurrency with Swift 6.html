<article class="post">
    <header class="post-header">
      <h1>Concurrency with Swift 6</h1>
      <time datetime="2025-08-02">02 August 2025</time>
    </header>

  <main class="post-content">
    <section class="post-section">
      <p>
        In recent years, Swift's concurrency model has evolved significantly, with each WWDC bringing new updates and
        improvements. While the ideas behind these changes are sound, concurrency can still be a challenging topic to fully
        grasp. If you're new to the subject, I recommend reading my

        <span class="external-link">
              <a href="https://alperozturk.me/src/blog/post/post.html?path=..%2F..%2Fblog%2Fpost%2FcomputerScience%2Fconcurrency%2FConcurrency.html">previous</a>
        </span>

        blog post on general concurrency concepts before
        continuing, it will provide helpful context and make this post easier to follow.
      </p>
    </section>

    <section class="post-section">
      <h2>Concepts</h2>
      <p>
        Before diving into code or

        <span class="external-link">
              <a href="https://www.swift.org/migration/documentation/migrationguide/">migrating to Swift 6</a>
        </span>

        , it's crucial to understand the foundational concepts of concurrency.
        What are actors, the MainActor, isolated, non-isolated, Sendable, parallelism, and concurrency? Without a solid
        grasp of these core ideas, it's challenging to build a reliable and maintainable project.
      </p>

      <h2>Sendable</h2>
      <p>
        When sharing data or state across multiple tasks, race conditions can arise. To prevent such issues, programming
        languages offer various solutions. In Swift, the


        <span class="external-link">
              <a href="https://developer.apple.com/documentation/Swift/Sendable"> Sendable protocol</a>
        </span>

        allows you to safely share data between tasks, as long as the data types conform to the protocol.
      </p>

      <p>
        Consider a scenario where multiple users attempt to modify a post simultaneously. Direct modifications are unsafe
        because we cannot guarantee data consistency. Therefore, it’s essential to ensure we’re updating the latest state
        before applying any changes.
      </p>

      <p>
        Let’s examine a common concurrency problem using a basic example: launching 1,000 concurrent tasks that attempt
        to update a shared Post object.
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
class Post {
    let title: String
    let description: String
    private var _likeCount: Int = 0

    init(title: String, description: String, likeCount: Int) {
        self.title = title
        self.description = description
        self._likeCount = likeCount
    }

    var likeCount: Int {
        return _likeCount
    }

    func like() {
        _likeCount += 1
    }
}


class PostRepository: @unchecked Sendable {
    let post: Post = .init(title: "test", description: "demo", likeCount: 0)

    func likePost() async {
        await withTaskGroup(of: Void.self) { group in
            for _ in 1...1000 {
                group.addTask {
                    await self.likePostConcurrently()
                }
            }
        }
        print("Expected: 1000, Actual: \(post.likeCount)")
    }

    private func likePostConcurrently() async {
        post.like()
    }
}
</code></pre>
      </div>

      <p>
        In this example, 1,000 concurrent tasks call post.like(). Since Post is a class with mutable state and no
        synchronization mechanism, this results in a race condition.
      </p>

      <p>
        By using <code>@unchecked Sendable</code>, we inform the compiler that we are taking responsibility for ensuring the
        thread-safety of the type. Without this annotation, the compiler emits an error such as the following:
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
Passing closure as a 'sending' parameter risks causing data races between code in the current task and concurrent execution of the closure.
</code></pre>
      </div>

      <p>
        The output may look like:
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
Expected: 1000, Actual: 983.
</code></pre>
      </div>

      <p>
        This occurs because multiple threads are accessing and modifying _likeCount simultaneously, leading to lost updates.
      </p>

      <h3>Default Actor Isolation</h3>
      <p>
        You can configure the default actor isolation behavior between nonisolated or MainActor.
        It is generally recommended to default to MainActor this ensures your isolated methods execute on the main thread
        unless explicitly overridden.
      </p>

      <p>
        For computationally intensive tasks or background operations, you should offload the work to a background thread
        allowing Swift's concurrency system to manage thread usage efficiently.
      </p>

      <img class="post-img" src="/src/blog/post/swift/concurrencyWithSwift6/1.png" alt="Swift Compiler Concurrency screenshot">

      <p>
        The default actor isolation level is currently set to "non-isolated."
      </p>

      <p>
        If you annotate the PostRepository class with

        <span class="external-link">
              <a href="https://developer.apple.com/documentation/swift/mainactor">@MainActor</a>
        </span>

        or set the default actor isolation level to MainActor you can remove the <code>@unchecked Sendable</code> annotation.

        @MainActor ensures that all code within the class is isolated to the main actor's execution context. This provides
        synchronization by serializing access to the shared state, with the additional guarantee that UI-related operations
        execute on the main dispatch queue.

        As a result, the compiler allows the code to compile successfully and outputs:
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
Expected: 1000, Actual: 1000.
</code></pre>
      </div>

      <p>
        While @MainActor is useful for ensuring thread safety on the main thread, there are many scenarios, especially
        involving heavy computations, where executing tasks in the background is necessary to avoid blocking the main thread
        or freezing the UI.
      </p>

      <p>
        In such cases, any shared mutable state must be accessed and modified safely. One approach is to make the shared
        class, such as Post, conform to the Sendable protocol. This allows instances of the class to be passed across
        concurrency domains safely.
      </p>

      <p>
        However, if we attempt to make the Post class conform to Sendable, Swift will emit a compile-time error:
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
“Stored property '_likeCount' of 'Sendable'-conforming class 'Post' is mutable.”
</code></pre>
      </div>

      <p>
        First of all Post class must be a final class, and it should not have superclass or have NSObject as the superclass.
      </p>

      <p>
        When working with shared mutable state in a background context, one effective solution is to use a lock to synchronize access.
        Apple provides

        <span class="external-link">
              <a href="https://developer.apple.com/documentation/os/osallocatedunfairlock">OSAllocatedUnfairLock</a>
        </span>

        in the os module, which offers efficient, low-level locking with minimal overhead.
      </p>

      <p>
        By wrapping access to mutable properties inside a lock, we can ensure safe concurrent reads and writes.
        This approach eliminates race conditions and provides consistent results.
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
import os

final class Post: Sendable {
    let title: String
    let description: String
    private let _likeCount = OSAllocatedUnfairLock(initialState: 0)

    init(title: String, description: String, likeCount: Int) {
        self.title = title
        self.description = description
        _likeCount.withLock { $0 = likeCount }
    }

    var likeCount: Int {
        return _likeCount.withLock { $0 }
    }

    func like() {
        _likeCount.withLock { $0 += 1 }
    }
}
</code></pre>
      </div>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
Expected: 1000, Actual: 1000.
</code></pre>
      </div>

      <h2>Actor</h2>
      <p>
        Do we need to use a class in this situation? Swift's concurrency model introduces the

        <span class="external-link">
              <a href="https://developer.apple.com/documentation/swift/actor">Actors</a>
        </span>

        type, designed to protect mutable state through isolation. When you
        define a method or property within an actor, it is automatically isolated. This means only one task at a time can
        access or modify the actor’s internal state, ensuring thread safety without requiring locks.
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
actor Post {
    let title: String
    let description: String
    private var likeCountValue: Int

    init(title: String, description: String, likeCount: Int) {
        self.title = title
        self.description = description
        self.likeCountValue = likeCount
    }

    var likeCount: Int {
        return likeCountValue
    }

    func like() {
        likeCountValue += 1
    }
}

class PostRepository: @unchecked Sendable {
    let post: Post = .init(title: "test", description: "demo", likeCount: 0)

    func likePost() async {
        await withTaskGroup(of: Void.self) { group in
            for _ in 1...1000 {
                group.addTask {
                    await self.likePostConcurrently()
                }
            }
        }
        print("Expected: 1000, Actual: \(await post.likeCount)")
    }

    private func likePostConcurrently() async {
        await post.like()
    }
}
</code></pre>
      </div>
      <p>
        By converting our <code>Post</code> class to an <code>actor</code>, we ensure that its internal mutable state is
        protected through actor isolation. Accessing its properties or methods from outside requires the <code>await</code>
        keyword, which serializes access and prevents race conditions.
      </p>

      <p>
        However, we're still marking <code>PostRepository</code> as <code>@unchecked Sendable</code>. Why? Because
        <code>PostRepository</code> is a class a reference type and reference types are inherently not thread-safe.
        Multiple concurrent tasks could access and mutate the same instance simultaneously. Even if the <code>post</code>
        property inside it is safe (since it's an actor), the <strong>reference to that property</strong> is not protected.
      </p>

      <p>
        For example, if one task reads <code>self.post</code> while another assigns a new <code>Post</code> instance to it,
        that introduces a race condition on the reference itself. The actor doesn't protect the enclosing object, it only
        protects its own internal state. This is why classes like <code>PostRepository</code> must either be:
      </p>

      <ul>
        <li>Properly synchronized</li>
        <li>Isolated with <code>@MainActor</code> or another actor</li>
        <li>Rewritten as a <code>struct</code> (a value type) that conforms to <code>Sendable</code>.</li>
      </ul>

      <p>
        Classes shared across concurrency domains require extra care, since their memory is shared, and any mutation
        or reassignment from multiple tasks may lead to data races, even if the properties they point to are otherwise thread-safe.
      </p>

      <h2>struct & Sendable</h2>
      <p>
        By converting PostRepository class into a <code>struct</code> and conforming it to the <code>Sendable</code> protocol,
        we can eliminate the need for <code>@unchecked</code> entirely.
      </p>

      <p>
        With Swift 6 and the default actor isolation set to <code>nonisolated</code>, this code compiles cleanly, without
        suppressing any compiler warnings because the struct is value type-safe and immutable by default, and all shared mutable
        state remains protected inside the <code>Post</code> actor.
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
actor Post {
    let title: String
    let description: String
    private var _likeCount: Int = 0

    init(title: String, description: String, likeCount: Int) {
        self.title = title
        self.description = description
        self._likeCount = likeCount
    }

    var likeCount: Int {
        return _likeCount
    }

    func like() {
        _likeCount += 1
    }
}


struct PostRepository: Sendable {
    let post: Post = .init(title: "test", description: "demo", likeCount: 0)

    func likePost() async {
        await withTaskGroup(of: Void.self) { group in
            for _ in 1...1000 {
                group.addTask {
                    await self.likePostConcurrently()
                }
            }
        }
        print("Expected: 1000, Actual: \(await post.likeCount)")
    }

    private func likePostConcurrently() async {
        await post.like()
    }
}
</code></pre>
      </div>

      <h2>Isolated, Non-Isolated</h2>
      <p>
        For example, the like() function below is an isolated method. It has exclusive access to the actor’s mutable state:
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
actor Post {
    let title: String
    let description: String
    private var likeCountValue: Int

    private let tag = "Post - Actor"

    init(title: String, description: String, likeCount: Int) {
        self.title = title
        self.description = description
        self.likeCountValue = likeCount
    }

    var likeCount: Int {
        return likeCountValue
    }

    func like() {
        likeCountValue += 1
    }

    nonisolated func log(_ message: String) {
        print(tag + " : " + message)
    }
}
</code></pre>
      </div>

      <p>
        By default, all methods inside an actor are isolated. However, if a method doesn’t interact with the actor's mutable
        state or needs to be accessed without requiring the actor’s isolation context, you can mark it with the nonisolated
        keyword. This allows the method to run on any thread without going through the actor's queue.
      </p>

      <p>
        The log(_:) function is marked nonisolated. It doesn’t touch any mutable state and is safe
        to call from outside the actor’s context, even on different threads.
      </p>

      <h3>When to Use nonisolated?</h3>
      <ul>
        <li>The function does not depend on the actor’s internal mutable state.</li>
        <li>The method must be available from any context or thread.</li>
        <li>You're building a library or API and want consumers to decide which thread or context to run a function on.</li>
      </ul>

      <h2>Parallelism</h2>
      <p>
        Now, imagine we need to process multiple files concurrently. Since the tasks are independent, they can run in parallel
        without blocking each other.
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
struct FileProcessor {
    func processFilesInParallel(_ filePaths: [String]) async -> ProcessingResult {
        await withTaskGroup(of: FileResult.self, returning: ProcessingResult.self) { group in
            for filePath in filePaths {
                group.addTask {
                    await processFile(filePath)
                }
            }

            var successCount = 0
            var failureCount = 0
            var totalSize = 0

            for await result in group {
                switch result {
                case .success(let size):
                    successCount += 1
                    totalSize += size
                case .failure:
                    failureCount += 1
                }
            }

            return ProcessingResult(
                successCount: successCount,
                failureCount: failureCount,
                totalSizeProcessed: totalSize
            )
        }
    }

    private func processFile(_ path: String) async -> FileResult {
        print("Processing file: \(path)")

        do {
            let processingTime = Double.random(in: 0.5...2.0)
            try await Task.sleep(for: .seconds(processingTime))

            let fileSize = Int.random(in: 1000...10000)
            print("Completed processing: \(path) (size: \(fileSize) bytes)")

            return .success(size: fileSize)
        } catch {
            print("Failed processing: \(path)")
            return .failure(error: error)
        }
    }
}

enum FileResult {
    case success(size: Int)
    case failure(error: Error)
}

struct ProcessingResult {
    let successCount: Int
    let failureCount: Int
    let totalSizeProcessed: Int
}
</code></pre>
      </div>
      <p>
        Using withTaskGroup, we can process files concurrently. As seen in the output, tasks complete in a non-sequential order,
        demonstrating parallel execution.
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
Processing file: file1.txt
Processing file: file2.txt
Processing file: file3.txt
Processing file: file4.txt
Processing file: file5.txt

Completed processing: file2.txt (size: 7391 bytes)
Completed processing: file3.txt (size: 9347 bytes)
Completed processing: file5.txt (size: 8953 bytes)
Completed processing: file4.txt (size: 4220 bytes)
Completed processing: file1.txt (size: 8947 bytes)
</code></pre>
      </div>

      <p>
        Alternatively, you can achieve similar results using async let. This syntax allows multiple tasks to be launched
        in parallel and awaited collectively. The completion order still varies, proving that these operations execute in
        parallel.
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
func processFilesInParallel(_ filePaths: [String]) async -> ProcessingResult {
        // Launch all tasks in parallel
        async let file1 = processFile(filePaths[0])
        async let file2 = processFile(filePaths[1])
        async let file3 = processFile(filePaths[2])
        async let file4 = processFile(filePaths[3])
        async let file5 = processFile(filePaths[4])

        // Wait for all tasks to complete
        let results = await [file1, file2, file3, file4, file5]

        var successCount = 0
        var failureCount = 0
        var totalSize = 0

        for result in results {
            switch result {
            case .success(let size):
                successCount += 1
                totalSize += size
            case .failure:
                failureCount += 1
            }
        }

        return ProcessingResult(
            successCount: successCount,
            failureCount: failureCount,
            totalSizeProcessed: totalSize
        )
    }
</code></pre>
      </div>
      <p>
        Output:
      </p>
      <div class="code-container">
        <button class="copy-button" title="Copy">Copy</button>
        <pre><code class="language-swift">
Processing file: file1.txt
Processing file: file2.txt
Processing file: file3.txt
Processing file: file4.txt
Processing file: file5.txt

Completed processing: file5.txt (size: 1628 bytes)
Completed processing: file3.txt (size: 1741 bytes)
Completed processing: file1.txt (size: 3003 bytes)
Completed processing: file2.txt (size: 8394 bytes)
Completed processing: file4.txt (size: 3064 bytes)
</code></pre>
      </div>

      <h2>Conclusion</h2>
      <p>
        Concurrency is a broad topic with multiple ways to avoid common pitfalls like race conditions. You can use low-level
        locking tools like

        <span class="external-link">
              <a href="https://developer.apple.com/documentation/os/os_unfair_lock">os_unfair_lock</a>
        </span>

        ,


        <span class="external-link">
              <a href="https://developer.apple.com/documentation/foundation/nslock">NSLock</a>
        </span>

        , or

        <span class="external-link">
              <a href="https://developer.apple.com/documentation/os/osallocatedunfairlock">OSAllocatedUnfairLock</a>
        </span>

        . Alternatively,


        <span class="external-link">
              <a href="https://developer.apple.com/documentation/dispatch/dispatchqueue/sync(execute:)-3segw">DispatchQueue.sync</a>
        </span>

        can ensure serial execution.
      </p>

      <p>
        However, modern Swift offers a solution through actors and the Sendable protocol. With Swift 6 and improved
        compiler support, we can now write concurrent code that is safer, more readable, and less error-prone.
      </p>
    </section>
  </main>
</article>