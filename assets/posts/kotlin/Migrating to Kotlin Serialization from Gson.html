<h1>Migrating to Kotlin Serialization from Gson</h1>

<p>
  <br>
  Recently, I was working on some improvements for my launcher app, <strong>Text Launcher</strong>. While updating dependencies and cleaning up old code, I realized that the logic used for exporting and importing launcher settings had become unnecessarily verbose. This was especially true when relying on <code>JsonSerializer</code> in Gson.
  <br><br>
</p>


<h2>Use Case</h2>
<p>
  <br>
  Before diving into the implementation details, let me explain the context. In my launcher app, users can customize their home screen with apps, organize them into folders, and tweak various settings such as background and content colors.
  <br><br>
  Now imagine switching to a new Android device — would you want to recreate all your folders, place apps one by one, and reapply your settings from scratch? Definitely not. To solve this, I implemented an export/import feature that generates a JSON file representing the full configuration. This file can later be imported to restore everything.
  <br><br>
  Sure, cloud storage (like Firebase or Supabase) could make this process automatic. But in the interest of simplicity and privacy, I’ve designed this app to work entirely offline, using only the minimal required permissions.
  <br><br>
</p>

<h2>Solution</h2>
<p>
  <br>
  The app makes use of several <code>data</code> classes, which are also used as Room entities. Many of these hold nested or complex data structures. To serialize and deserialize them using Gson, a custom <code>JsonSerializer</code> is needed.
  <br><br>
  Let's look at a real example.
  <br><br>
</p>

<h3>App data class</h3>
<p>
  <br>
  This data class represents an installed app, along with its current state (e.g. <code>InFolder</code>, <code>Home</code>, <code>Hidden</code>, or <code>Favorite</code>).
  <br><br>
</p>
<div class="code-container">
  <button class="copy-button" title="Copy">Copy</button>
  <pre>
        <code class="language-kotlin">
@Entity(tableName = "apps")
data class App(
    val name: String,

    @SerializedName("package_name")
    @PrimaryKey
    val packageName: String,

    val state: AppState,
) {
    // helper methods ...
}
        </code>
    </pre>
</div>

<h3>AppState</h3>
<p>
  <br>
  As shown below, <code>AppState</code> is a sealed class. Since the <code>App</code> class includes a property of this sealed type, Gson doesn't support serializing/deserializing it out-of-the-box.
  <br><br>
</p>
<div class="code-container">
  <button class="copy-button" title="Copy">Copy</button>
  <pre><code class="language-kotlin">
sealed class AppState {
    data object List : AppState()
    data object Favorite : AppState()
    data class Home(val order: Int) : AppState()
    data object Hidden : AppState()
    data object InFolder : AppState()

    fun getTrailingImageVector(): ImageVector? {
        return when (this) {
            is Favorite -> Icons.Filled.Star
            is Home -> null
            else -> Icons.Filled.MoreVert
        }
    }
}
  </code></pre>
</div>


<h4>Object to JSON</h4>
<div class="code-container">
  <button class="copy-button" title="Copy">Copy</button>
  <pre><code class="language-kotlin">
val gson = Gson()
val app = App(
    name = "YouTube",
    packageName = "com.google.android.youtube",
    state = AppState.Favorite
)
val jsonString = gson.toJson(app)
println(jsonString)

  </code></pre>
</div>

<h4>Json to Object</h4>
<div class="code-container">
  <button class="copy-button" title="Copy">Copy</button>
  <pre><code class="language-kotlin">
val jsonInput = """
{
  "name": "YouTube",
  "package_name": "com.google.android.youtube",
  "state": {
    "type": "Favorite"
  }
}
"""
val appObj = gson.fromJson(jsonInput, App::class.java)
println(appObj)
  </code></pre>
</div>


<p>
  <br>
  Direct conversion like this won't work because Gson doesn’t inherently understand sealed classes or their structure. To resolve this, we must define a custom <code>JsonSerializer</code> and <code>JsonDeserializer</code>. Also, since these objects are stored in Room, we need to provide proper <code>TypeConverters</code>.
  <br><br>
</p>

<div class="code-container">
  <button class="copy-button" title="Copy">Copy</button>
  <pre><code class="language-kotlin">
import androidx.room.TypeConverter
import com.coolnexttech.textlauncher.db.model.App
import com.coolnexttech.textlauncher.db.model.AppState
import com.coolnexttech.textlauncher.db.serializer.AppStateJsonSerializer
import com.google.gson.GsonBuilder
import com.google.gson.reflect.TypeToken

class AppListConverter {
    private val gson = GsonBuilder()
        .registerTypeAdapter(AppState::class.java, AppStateJsonSerializer())
        .create()

    @TypeConverter
    fun fromAppList(apps: List< App>?): String? {
        return gson.toJson(apps)
    }

    @TypeConverter
    fun toAppList(appJson: String?): List< App>? {
        if (appJson.isNullOrEmpty()) return emptyList()
        val type = object : TypeToken&lt;List&lt;App&gt;&gt;() {}.type
        return gson.fromJson(appJson, type)
    }
}

import com.coolnexttech.textlauncher.db.model.AppState
import com.google.gson.JsonDeserializationContext
import com.google.gson.JsonDeserializer
import com.google.gson.JsonElement
import com.google.gson.JsonObject
import com.google.gson.JsonSerializationContext
import com.google.gson.JsonSerializer
import java.lang.reflect.Type

class AppStateJsonSerializer : JsonSerializer&lt;AppState&gt;, JsonDeserializer&lt;AppState&gt; {
    override fun serialize(
        src: AppState,
        typeOfSrc: Type,
        context: JsonSerializationContext
    ): JsonElement {
        val jsonObject = JsonObject()
        when (src) {
            is AppState.List -&gt; jsonObject.addProperty("type", "List")
            is AppState.Favorite -&gt; jsonObject.addProperty("type", "Favorite")
            is AppState.Home -&gt; {
                jsonObject.addProperty("type", "Home")
                jsonObject.addProperty("order", src.order)
            }
            is AppState.Hidden -&gt; jsonObject.addProperty("type", "Hidden")
            is AppState.InFolder -&gt; jsonObject.addProperty("type", "InFolder")
        }
        return jsonObject
    }

    override fun deserialize(
        json: JsonElement,
        typeOfT: Type,
        context: JsonDeserializationContext
    ): AppState {
        val jsonObject = json.asJsonObject
        val typeElement = jsonObject.get("type")

        if (typeElement == null || typeElement.isJsonNull) {
            return AppState.List
        }

        return when (typeElement.asString) {
            "List" -&gt; AppState.List
            "Favorite" -&gt; AppState.Favorite
            "Home" -&gt; {
                val orderElement = jsonObject.get("order")
                if (orderElement != null &amp;&amp; !orderElement.isJsonNull) {
                    AppState.Home(orderElement.asInt)
                } else {
                    AppState.Home(0)
                }
            }
            "Hidden" -&gt; AppState.Hidden
            "InFolder" -&gt; AppState.InFolder
            else -&gt; AppState.List
        }
    }
}
  </code></pre>
</div>

<h3>Why I Wasn't Happy with This Approach</h3>
<p>
  <br>
  While this setup works, it introduces unnecessary complexity. Writing custom serializers/deserializers for every sealed class quickly becomes tedious and error-prone.
  <br><br>
</p>

<h2>A Better Way: Kotlin Serialization</h2>
<p>
  <br>
  First of all, Gson is primarily a Java-based solution. It's not optimized for modern Kotlin-based Android development.
  <br><br>
  Gson uses a reflection-based approach, which means it inspects class structures at runtime to determine fields and types. This can lead to issues with tools like ProGuard or R8, which are often used during release builds to shrink, optimize, and obfuscate the app.
  <br><br>
</p>

<h2>What the heck is the reflection-based approach?</h2>
<p>
  <br>
  Well, it's basically that Gson doesn't know ahead of time what fields your class has. So at runtime, it inspects the class to find all its fields and methods, reads the field names and types, then converts them to JSON.
  <br><br>
</p>

<h2>Why Kotlinx Serialization is Better</h2>
<p>
  <br>
  Kotlinx Serialization solves these problems by generating serialization code at compile time. This eliminates the need for reflection entirely. It understands your data structures ahead of time and creates efficient, optimized code for both serialization and deserialization.
  <br><br>
  This approach is faster, safer, and works seamlessly with sealed classes.
  <br><br>
</p>

<h2>New solution</h2>
<p>
  <br>
  With Kotlinx Serialization, all I need to do is add the <code>@Serializable</code> annotation to my data classes — no more writing custom serializers!
  <br><br>
</p>

<div class="code-container">
  <button class="copy-button" title="Copy">Copy</button>
  <pre><code class="language-kotlin">
import androidx.room.TypeConverter
import com.coolnexttech.textlauncher.db.model.App
import kotlinx.serialization.json.Json

class AppListConverter {
    @TypeConverter
    fun fromAppList(apps: List&lt;App&gt;?): String? {
        return apps?.let { Json.encodeToString(it) }
    }

    @TypeConverter
    fun toAppList(appJson: String?): List&lt;App&gt;? {
        return appJson?.let { Json.decodeFromString&lt;List&lt;App&gt;&gt;(it) } ?: emptyList()
    }
}

import androidx.room.Entity
import androidx.room.PrimaryKey
import com.coolnexttech.textlauncher.R
import com.coolnexttech.textlauncher.ui.model.ActionBottomSheetData
import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

@Serializable
@Entity(tableName = "apps")
data class App(
    val name: String,

    @SerialName("package_name")
    @PrimaryKey
    val packageName: String,

    val state: AppState,
) {
    // Helper methods ...
}

@Serializable
sealed class AppState {
    @Serializable
    @SerialName("List")
    data object List : AppState()

    @Serializable
    @SerialName("Favorite")
    data object Favorite : AppState()

    @Serializable
    @SerialName("Home")
    data class Home(val order: Int) : AppState()

    @Serializable
    @SerialName("Hidden")
    data object Hidden : AppState()

    @Serializable
    @SerialName("InFolder")
    data object InFolder : AppState()

    fun getTrailingImageVector(): ImageVector? {
        return when (this) {
            is Favorite -&gt; Icons.Filled.Star
            is Home -&gt; null
            else -&gt; Icons.Filled.MoreVert
        }
    }
}
  </code></pre>
</div>
