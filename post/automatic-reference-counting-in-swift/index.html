<article class="post">
    <header class="post-header">
        <h1>Automatic Reference Counting in Swift</h1>
        <time datetime="2025-10-03">3 October 2025</time>
    </header>

    <main class="post-content">
        <section class="post-section">
            <p>
                You’ve probably heard of memory leaks before and applied a bunch of methods to prevent them
                during your iOS development journey. In this blogpost, we’ll discuss what memory leaks are,
                why they matter, and how Swift’s ARC helps us manage memory effectively.
            </p>
        </section>

        <section class="post-section">
            <h2>What's Memory Leak?</h2>
            <p>
                When we allocate variables or objects, the system reserves memory for them. Once we are done
                with these objects, that memory should be released so it can be reused. A memory leak happens
                when this deallocation does not occur, leaving memory occupied even though the object is no
                longer needed.
            </p>

            <p>
                Over time, unreleased objects accumulate and consume system resources unnecessarily. Even if
                the leak is small, repeated occurrences can lead to degraded performance or, in severe cases,
                app termination by the system due to memory pressure.
            </p>
        </section>

        <section class="post-section">
            <h2>Are Memory Leaks Really That Important?</h2>
            <p>
                The impact depends on size and frequency. For example, leaking a simple class instance of 8 KB
                a few times probably won’t crash your app. But if that class participates in a chain of
                references or is used in a repetitive process like polling, memory usage can quickly grow out
                of control, harming performance and user experience.
            </p>

            <p>
                Another challenge is unpredictability. Complex apps often have execution flows you can’t fully
                foresee. As engineers, it’s our responsibility to build scalable, maintainable, and robust
                architectures that manage memory reliably in all scenarios.
            </p>
        </section>

        <section class="post-section">
            <h2>What is ARC?</h2>
            <p>
                <strong>Automatic Reference Counting</strong>

                <span class="external-link">
                     <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/automaticreferencecounting/">(ARC)</a>
                </span>

                is Swift’s memory management system. Every
                time we create a new instance of a class or actor, ARC allocates memory for it and keeps a
                count of strong references. When the reference count drops to zero, ARC automatically
                deallocates the object.
            </p>

            <ul>
                <li>Each new strong reference increments the count</li>
                <li>Each released strong reference decrements the count</li>
                <li>If a cycle exists (two objects strongly reference each other), the count never reaches zero
                    and ARC cannot free the memory
                </li>
            </ul>
        </section>

        <section class="post-section">
            <h2>Value And Reference Types</h2>
            <p>
                In Swift programming language, we have two types, value and reference types. Value types create a new
                copy when
                assigned, while reference types share the same underlying instance in memory.
            </p>

            <p>
                In the code below, we use a struct. When we assign <code>firstCar</code> to
                <code>secondCar</code>, a new copy is made. Changing <code>secondCar</code> does not affect
                <code>firstCar</code>.
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
struct Car {
    var modelname: String
    let hp: Int
}

let firstCar = Car(modelname: "FirstCar", hp: 110)
var secondCar = firstCar

secondCar.modelname = "SecondCar"

print(firstCar.modelname) // FirstCar
print(secondCar.modelname) // SecondCar
</code></pre>
            </div>

            <p>
                With classes, however, both variables point to the same memory. Updating one, updates the other
                as well, since they are just two references to the same instance.
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
class Car {
    var modelname: String
    let hp: Int

    init(modelname: String, hp: Int) {
        self.modelname = modelname
        self.hp = hp
    }
}

let firstCar = Car(modelname: "FirstCar", hp: 110)
var secondCar = firstCar

secondCar.modelname = "SecondCar"

print(firstCar.modelname) // SecondCar
print(secondCar.modelname) // SecondCar
</code></pre>
            </div>
        </section>

        <section class="post-section">
            <h2>Relationships Between Reference Types</h2>
            <p>
                In Swift, references can be <strong>strong</strong>, <strong>weak</strong>, or
                <strong>unowned</strong>. These determine how ARC counts references and when objects can be deallocated.
            </p>

            <p>
                By understanding these relationships, you gain control over object lifetimes and can prevent
                memory leaks.
            </p>

            <h3>Strong</h3>
            <p>
                By default, references are <em>strong</em>. A strong reference increases the retain count,
                keeping the object alive as long as there is at least one strong reference to it.
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
class Car {
    var modelname: String
    let hp: Int

    init(modelname: String, hp: Int) {
        self.modelname = modelname
        self.hp = hp
    }
}

class Owner {
    let car: Car

    init(car: Car) {
        self.car = car
    }
}
</code></pre>
            </div>

            <h3>Weak</h3>
            <p>
                Declaring a reference as "weak" means that

                <span class="external-link">
                     <a href="https://developer.apple.com/videos/play/wwdc2021/10216/?time=380">it does not participate</a>
                </span>

                in reference counting.

                Weak references are always <code>Optional</code> and automatically set to <code>nil</code> when the
                referenced object is deallocated. This makes them safe to use when the referenced object may
                go away before the holder.
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
class Car {
    var modelname: String
    let hp: Int

    init(modelname: String, hp: Int) {
        self.modelname = modelname
        self.hp = hp
    }
}

class Owner {
    weak var car: Car?

    init(car: Car) {
        self.car = car
    }
}
</code></pre>
            </div>

            <p>
                For example, you can use a weak reference type in the delegation, pattern.
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
protocol ImageProcessingDelegate: AnyObject {
    func process(_ data: Data)
}

class ImageProcessor {
    weak var delegate: ImageProcessingDelegate?

    func prepareImageAndProcess(_ url: String) {
        // prepare logic
        // ...
        // ...
        let data = Data()
        delegate?.process(data)
    }
}

final class ViewController: UIViewController {
    private let imageProcessor = ImageProcessor()

    override func viewDidLoad() {
        super.viewDidLoad()
        imageProcessor.delegate = self
        imageProcessor.prepareImageAndProcess("some_image_url")
    }
}

extension ViewController: @MainActor ImageProcessingDelegate {
    func process(_ data: Data) {
        // process logic ...
    }
}
</code></pre>
            </div>

            <h3>Unowned</h3>
            <p>
                An <code>unowned</code> reference also does not participate the retain count, but unlike
                <code>weak</code>, it is non-optional. ARC does not set it to <code>nil</code> when the object
                is freed. Accessing it after deallocation will cause a runtime crash. That’s why
                <code>unowned</code> is only safe when the lifetime of the referenced object is guaranteed to
                be same or longer than the one holding it.
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
class CreditCard {
    let number: String
    unowned let customer: Customer

    init(number: String, customer: Customer) {
        self.number = number
        self.customer = customer
    }
}

class Customer {
    let name: String
    var card: CreditCard?

    init(name: String) {
        self.name = name
    }
}
</code></pre>
            </div>
        </section>

        <section class="post-section">
            <h2>Common Leak Scenarios and Solutions</h2>

            <h3>Strong Cycles Between Objects</h3>
            <p>
                In the following code, <code>Car</code> has a reference to <code>Owner</code> and
                <code>Owner</code> has a reference to <code>Car</code>. Both are strong, so neither object’s
                retain count can ever reach zero. As a result, their <code>deinit</code> methods never run.
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
class Car {
    var modelname: String
    let hp: Int
    var owner: Owner?

    init(modelname: String, hp: Int) {
        self.modelname = modelname
        self.hp = hp
    }

    deinit { print("Car deallocated") }
}

class Owner {
    let car: Car

    init(car: Car) {
        self.car = car
    }

    deinit { print("Owner deallocated") }
}

var owner: Owner? = Owner(car: Car(modelname: "Car", hp: 100))
owner?.car.owner = owner
owner = nil
</code></pre>
            </div>

            <p>
                To solve this, mark one side as <code>weak</code> or <code>unowned</code>, depending on the
                ownership model. Then ARC can correctly deallocate both objects.
            </p>

            <h3>Closures Capturing self</h3>
            <p>
                Another very common source of leaks is closures capturing <code>self</code> strongly. For
                example, this <code>ViewModel</code> may live longer than intended if it’s captured by a
                long-running task. If the user navigates away, the view is destroyed, but the
                <code>ViewModel</code> is kept alive by the closure.
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
class ViewModel {
    var data: [String] = []
    var timer: Timer?

    func longRunningTask() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            self.data.append("Loaded")
        }
    }

    func startTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) {
            self.tick()
        }
    }

    func asyncTask() {
        Task {
            await self.fetch()
        }
    }

    private func tick() {
        data.append("Tick")
    }

    private func fetch() async {
        try? await Task.sleep(nanoseconds: 1_000_000_000)
        data.append("Fetched")
    }
}
</code></pre>
            </div>

            <p>
                The fix is to capture <code>self</code> weakly inside closures. This ensures that when the
                <code>ViewModel</code> is no longer needed, it can be deallocated even if the closure hasn’t
                executed yet.
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
class ViewModel {
    var data: [String] = []
    var timer: Timer?

    func longRunningTask() {
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) { [weak self] in
            self?.data.append("Loaded")
        }
    }

    func startTimer() {
        timer = Timer.scheduledTimer(withTimeInterval: 1, repeats: true) { [weak self] _ in
            self?.tick()
        }
    }

    func asyncTask() {
        Task { [weak self] in
            await self?.fetch()
        }
    }

    private func tick() {
        data.append("Tick")
    }

    private func fetch() async {
        try? await Task.sleep(nanoseconds: 1_000_000_000)
        data.append("Fetched")
    }

    deinit {
        timer?.invalidate()
        print("ViewModel deallocated")
    }
}
</code></pre>
            </div>

            <p>
                Timers strongly retain their targets (in this example, the closure), so it's critical to invalidate them
                in deinit (as shown above) to prevent the timer from keeping the ViewModel alive indefinitely.
            </p>

            <p>
                Any class can leak if its references are not managed correctly.
                For instance, a transaction history class linked to a user object, which in turn references other objects,
                can easily form cycles if ownership is not carefully designed.
            </p>

            <p> To build a good architecture, we should ask ourselves the following questions: </p>
            <ul>
                <li>Is there a long-running process keeping references alive (e.g., timers, tasks, observers)?</li>
                <li>Do we really need a class here, or would a value type such as a <code>struct</code> be sufficient?</li>
                <li>What is the intended lifecycle of this class—when should it be initialized, and when must it be guaranteed to deinitialize?</li>
            </ul>

            <p>
                Classes like <code>NotificationCenter</code>, <code>Timer</code> and background tasks, event-driven
                architectures are particularly prone to leaks if not designed with clear ownership and lifecycle
                management. Careful handling of these is essential for predictable and stable memory
                behavior.
            </p>
        </section>

        <section class="post-section">
            <h2>Conclusion</h2>
            <p>
                Memory leaks may start small, but if ignored, they accumulate and harm your app’s performance
                and stability. By understanding ARC and carefully managing <code>strong</code>,
                <code>weak</code>, and <code>unowned</code> references, you can design safer, more scalable,
                and more maintainable applications.
            </p>
        </section>
    </main>
</article>