<article class="post">
    <header class="post-header">
        <h1>Understanding FileManager API</h1>
        <time datetime="2025-10-18">18 October 2025</time>
    </header>

    <main class="post-content">
        <section class="post-section">
            <p>
                In this post, we‚Äôll explore Apple‚Äôs <strong>FileManager API</strong>, one of the most fundamental and widely used
                components of the Foundation framework. Understanding how it works is essential for any iOS or macOS developer who
                needs to interact with the file system.
            </p>

            <p>
                Before diving into FileManager, we‚Äôll start with <strong>URL</strong>, since most file system operations
                are performed using URL objects. Understanding URLs gives us the foundation to work confidently with files and
                directories in Apple‚Äôs platforms.
            </p>

            <h2>URL & NSURL</h2>
            <p>
                A <code>URL</code> represents the location of a resource, it can refer to a file on disk or a remote resource
                on the network. In Swift, <code>URL</code> is implemented as a <em>struct</em>, while <code>NSURL</code>
                is its Objective-C counterpart, implemented as a <em>class</em>.
            </p>

            <p>
                When working with remote resources, you‚Äôll typically use
                <span class="external-link">
                    <a href="https://developer.apple.com/documentation/foundation/url-loading-system">URL Loading System</a>
                </span>
                often through
                <span class="external-link">
                    <a href="https://developer.apple.com/documentation/foundation/urlsession">URLSession</a>
                </span>,
                to fetch or upload data.
            </p>

            <p>
                A <code>URL</code> can also be broken down into its individual components, such as scheme, host, port, path,
                and query parameters:
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
private func test() {
    let url: NSURL = .init(string: "https://lion.den@example.com:8080/info;param=pValue?query=qValue")! as NSURL
    print(url.scheme) // "https"
    print(url.user) // "lion.den"
    print(url.host) // "example.com"
    print(url.port) // 8080
    print(url.query) // "query=qValue"
    print(url.path) // "/info;param=pValue"
}
</code></pre>
            </div>

            <h2>Security-Scoped URLs</h2>
            <p>
                A <strong>security-scoped URL</strong> is a special type of URL that allows your app to access files and folders
                located outside of its sandbox. For example, when using
                <span class="external-link">
                    <a href="https://developer.apple.com/documentation/UIKit/UIDocumentPickerViewController">UIDocumentPickerViewController</a>
                </span>,
                the user can pick files or folders stored elsewhere on the device, such as in the Files app.
            </p>

            <p>
                The code below shows how to present a document picker that allows the user to select a folder. Once the user
                makes a selection, we gain temporary permission to read its contents by calling
                <span class="external-link">
                    <a href="https://developer.apple.com/documentation/foundation/nsurl/startaccessingsecurityscopedresource()">startAccessingSecurityScopedResource()</a>
                </span>
                . After that, we can use <code>FileManager</code> to access the files inside that folder safely.
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
extension GalleryViewController: UIDocumentPickerDelegate {
    private func showFolderPicker() {
        let picker = UIDocumentPickerViewController(forOpeningContentTypes: [.folder], asCopy: false)
        picker.delegate = self
        picker.allowsMultipleSelection = false
        present(picker, animated: true)
    }

    func documentPicker(_ controller: UIDocumentPickerViewController, didPickDocumentsAt urls: [URL]) {
        guard let folderURL = urls.first else { return }
        loadImages(from: folderURL)
    }

    private func loadImages(from folderURL: URL) {
        guard folderURL.startAccessingSecurityScopedResource() else { return }
        defer { folderURL.stopAccessingSecurityScopedResource() }

        do {
            let contents = try FileManager.default.contentsOfDirectory(at: folderURL, includingPropertiesForKeys: nil)

            let imageURLs = contents.filter { url in
                let ext = url.pathExtension.lowercased()
                return ["jpg", "jpeg", "png", "heic"].contains(ext)
            }

            gallerySource = imageURLs.map { $0.path }

            DispatchQueue.main.async {
                self.galleryCollectionView.reloadData()
            }
        } catch {
            print("Error reading folder contents:", error)
        }
    }
}
</code></pre>
            </div>

            <p>
                Understanding <code>URL</code> and how it represents both local and remote resources is essential before diving into
                <code>FileManager</code>. They work hand in hand: <code>URL</code> defines <em>where</em> something is, and
                <code>FileManager</code> defines <em>what</em> you can do with it.
            </p>

            <p>
                Think of them as building blocks, small, simple components that combine to form powerful systems.
            </p>

            <img class="post-img" src="/post/understanding-file-manager-api/document_picker_example.png" alt="Document picker example">

            <h2>FileManager</h2>
            <p>
                The <code>FileManager</code> API allows you to access, read, write, copy, and delete files both inside your app‚Äôs
                sandbox and, with proper permissions, outside of it. The system defines multiple directory types for different
                purposes, which we‚Äôll examine below.
            </p>

            <h3>User Directories</h3>
            <p>
                You can easily access your app‚Äôs temporary and home directories through either <code>FileManager</code> or
                the older Foundation functions in <code>NSPathUtils</code>. Note that while both give similar paths,
                their representations differ slightly (e.g. one returns a <code>URL</code> and the other a <code>String</code>).
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
private func printUserDirectories() {
   print(FileManager.default.temporaryDirectory) // file:///Users/testuser/Library/Developer/CoreSimulator/Devices/C23A251B-67F8-46ED-9DA4-FB8F72670E6E/data/Containers/Data/Application/FF7BEF5B-858B-48EF-ADA9-19B9D53D1274/tmp/
   print(NSTemporaryDirectory()) // /Users/testuser/Library/Developer/CoreSimulator/Devices/C23A251B-67F8-46ED-9DA4-FB8F72670E6E/data/Containers/Data/Application/FF7BEF5B-858B-48EF-ADA9-19B9D53D1274/tmp/

   print(NSHomeDirectory()) // /Users/testuser/Library/Developer/CoreSimulator/Devices/C23A251B-67F8-46ED-9DA4-FB8F72670E6E/data/Containers/Data/Application/FF7BEF5B-858B-48EF-ADA9-19B9D53D1274
}
</code></pre>
            </div>

            <h3>Working with System Directories</h3>
            <p>
                Two of the most useful FileManager functions are <code>url(for:in:)</code> and <code>urls(for:in:)</code>.
                These allow you to locate predefined system directories by specifying both a
                <code>SearchPathDirectory</code> (the type of directory) and a <code>SearchPathDomainMask</code> (the domain or
                scope where it exists).
            </p>

            <p>
                <code>SearchPathDirectory</code> is an enumeration that includes many directory types, such as:
            </p>

            <ul>
                <li>documentDirectory</li>
                <li>applicationDirectory</li>
                <li>applicationSupportDirectory</li>
                <li>adminApplicationDirectory</li>
                <li>libraryDirectory</li>
                <li>userDirectory</li>
                <li>documentationDirectory</li>
                <li>cachesDirectory</li>
                <li>‚Ä¶and more</li>
            </ul>

            <p>
                At first, these options may seem confusing, but once you understand what each represents, choosing the
                correct one becomes straightforward.
            </p>

            <p>
                For example:
            </p>

            <ul>
                <li><strong>Documents Directory</strong> ‚Üí for files that the user creates or interacts with directly.</li>
                <li><strong>Application Support Directory</strong> ‚Üí for configuration or internal files used by the app itself.</li>
                <li><strong>Caches Directory</strong> ‚Üí for temporary data that improves performance and can be safely deleted.</li>
            </ul>

            <p>
                The second parameter, <strong>SearchPathDomainMask</strong>, determines <em>where</em> the system looks for
                these directories, for example, in the local domain, the system domain, or the network domain.
            </p>

            <h3>Implementation</h3>
            <p>
                The following code demonstrates the simple crud operations.
            </p>
            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
struct FileManagerUtil {
    private let fileManager = FileManager.default

    private var documentsDirectory: URL {
        fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
    }

    private func fileURL(for name: String) -> URL {
        documentsDirectory.appendingPathComponent(name)
    }

    func createFile(named name: String, content: String) {
        let fileURL = fileURL(for: name)
        let data = Data(content.utf8)

        do {
            try data.write(to: fileURL)
            print("‚úÖ Created file at: \(fileURL.path)")
        } catch {
            print("‚ùå Failed to create file:", error)
        }
    }

    func readFile(named name: String) -> String? {
        let fileURL = fileURL(for: name)

        do {
            let data = try Data(contentsOf: fileURL)
            let text = String(decoding: data, as: UTF8.self)
            print("üìñ File contents:\n\(text)")
            return text
        } catch {
            print("‚ùå Failed to read file:", error)
            return nil
        }
    }

    func updateFile(named name: String, newContent: String) {
        let fileURL = fileURL(for: name)

        guard fileManager.fileExists(atPath: fileURL.path) else {
            print("‚ö†Ô∏è File doesn‚Äôt exist to update.")
            return
        }

        do {
            try newContent.write(to: fileURL, atomically: true, encoding: .utf8)
            print("‚úèÔ∏è Updated file at: \(fileURL.path)")
        } catch {
            print("‚ùå Failed to update file:", error)
        }
    }

    func deleteFile(named name: String) {
        let fileURL = fileURL(for: name)

        guard fileManager.fileExists(atPath: fileURL.path) else {
            print("‚ö†Ô∏è File doesn‚Äôt exist to delete.")
            return
        }

        do {
            try fileManager.removeItem(at: fileURL)
            print("üóëÔ∏è Deleted file at: \(fileURL.path)")
        } catch {
            print("‚ùå Failed to delete file:", error)
        }
    }

    func listDocumentsDirectory() {
        do {
            let contents = try fileManager.contentsOfDirectory(at: documentsDirectory, includingPropertiesForKeys: nil)
            print("üìÇ Documents Directory Contents:")
            contents.forEach { print("  ‚Ä¢ \($0.lastPathComponent)") }
        } catch {
            print("‚ùå Failed to list directory:", error)
        }
    }
}
</code></pre>
            </div>

            <p>
                Example usage:
            </p>

            <div class="code-container">
                <button class="copy-button" title="Copy">Copy</button>
                <pre><code class="language-swift">
let key = "my_secret_file"

// ‚úÖ Created file at: /Users/testuser/Library/Developer/CoreSimulator/Devices/C23A251B-67F8-46ED-9DA4-FB8F72670E6E/data/Containers/Data/Application/58779909-AC51-4F1C-A132-C7EDCF3F0BF3/Documents/my_secret_file
util.createFile(named: key, content: "Hello World")

// üìñ File contents: Hello World
let content = util.readFile(named: key)

// üìÇ Documents Directory Contents: ‚Ä¢ my_secret_file
util.listDocumentsDirectory()

‚úèÔ∏è Updated file at: /Users/testuser/Library/Developer/CoreSimulator/Devices/C23A251B-67F8-46ED-9DA4-FB8F72670E6E/data/Containers/Data/Application/0A01CB66-4673-4010-A69C-652CAC776300/Documents/my_secret_file
util.updateFile(named: key, newContent: "test_2")

// üìñ File contents: test_2
util.readFile(named: key)

// üóëÔ∏è Deleted file at: /Users/testuser/Library/Developer/CoreSimulator/Devices/C23A251B-67F8-46ED-9DA4-FB8F72670E6E/data/Containers/Data/Application/F5AD74C4-1871-44D5-9326-FFE07E8183FE/Documents/my_secret_file
util.deleteFile(named: key)

// ‚ùå Failed to read file: Error Domain=NSCocoaErrorDomain Code=260 "The file ‚Äúmy_secret_file‚Äù couldn‚Äôt be opened because there is no such file."
util.readFile(named: key)
</code></pre>
            </div>

            <h2>Conclusion</h2>
            <p>
                The <strong>FileManager</strong> API is one of the most powerful and essential tools provided by the Foundation framework.
                It serves as the backbone for managing files and directories across both macOS and iOS environments.
                It is a must-have skill in every Apple developer‚Äôs toolkit.
            </p>
        </section>
    </main>
</article>
